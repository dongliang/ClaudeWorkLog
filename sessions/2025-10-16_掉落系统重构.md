# 2025-10-16 掉落系统重构 - IRoller接口解耦

## 元信息
- **日期**: 2025-10-16
- **项目**: GuiRen.Server (游戏服务器)
- **技术栈**: C#, .NET 9, Orleans
- **主要问题**: 重构掉落系统,将硬编码的随机器逻辑抽象为接口,支持多种随机器类型
- **结果**: ✅成功

---

## 问题背景

用户想要优化 `BattleModule.cs` 中的 `CalculateDrops` 函数(实际位于 `drop_group.cs`)。这个函数用于单次掉落抽取(如击杀一个怪物),但存在以下问题:

1. **函数名不清晰**: `CalculateDrops` (复数)容易误解为"计算多次掉落"
2. **随机器逻辑硬编码**: 只支持 `normal` (概率判定),无法扩展
3. **职责不清**: `randomId` 和 `randomParams` 的关系模糊,不同随机器需求不同
   - `normal`: `randomParams` 是概率值 (如 "0.5")
   - `pet_ticket`: `randomParams` 是数量范围 (如 "{300,900}")

用户希望:
- 更好的函数名和注释
- 解耦随机器逻辑,支持扩展
- 简洁优雅的实现

---

## 工作过程

### 1. 理解问题阶段

- **发现的关键信息**:
  - `CalculateDrops` 实际是"单次掉落抽取",不是"多次"
  - 一个 `(stageId, dropTag)` 可以配置多个 `drop_group`,每个独立判定
  - `loopCount` 支持"多次抽奖"机制
  - `randomId` 不是开关,而是随机器类型标识
  - 不同随机器有不同的副作用:
    - `normal`: 影响"是否触发" (返回 bool)
    - `pet_ticket`: 影响"掉落数量" (返回 int)

- **核心矛盾**: 两种随机器的返回值类型不同,如何用统一接口?

### 2. 方案设计阶段

- **方案对比**:
  - **方案A - 结构体**: 返回 `RollResult { bool Ok, int Count }`
    - 优点: 语义清晰
    - 缺点: 需要自定义结构体,代码稍多

  - **方案B - int值**: 返回 `int`,0表示不触发,>0表示数量倍数
    - 优点: 极简,无需额外类型
    - 缺点: 0的语义不够明确

  - **方案C - Nullable**: 返回 `int?`,null表示不触发
    - 优点: null语义清晰,C#原生支持
    - 缺点: 需要 `.Value` 访问

- **最终选择**: 方案B (int值)
- **选择理由**: 用户明确要求"更少的字、更简单",方案B代码最简洁

### 3. 实现阶段

- **核心设计**:
  ```csharp
  // 接口定义
  public interface IRoller
  {
      int Roll(string param, Random random); // 0=不触发, >0=倍数
  }

  // Normal随机器 - 支持双模式
  class NormalRoller : IRoller
  {
      public int Roll(string param, Random random)
      {
          if (!float.TryParse(param, out var value))
              return 0;

          if (value < 1)
              return random.NextDouble() <= value ? 1 : 0; // 概率模式

          return (int)value; // 固定倍数模式
      }
  }

  // Range随机器
  class RangeRoller : IRoller
  {
      public int Roll(string param, Random random)
      {
          // 解析 "{300,900}" 返回 300-900 随机值
          var nums = param.Trim('{', '}').Split(',');
          if (nums.Length != 2) return 0;

          var min = int.Parse(nums[0].Trim());
          var max = int.Parse(nums[1].Trim());
          return random.Next(min, max + 1);
      }
  }
  ```

- **关键改进点**:
  1. 函数重命名: `CalculateDrops` → `RollDrop`
  2. 添加清晰注释: 说明"单次掉落"概念,附带使用示例
  3. 动态调用随机器: 根据 `randomId` 查字典获取对应 `IRoller`
  4. 统一计算逻辑: `最终数量 = 基础数量 × 随机器倍数`

- **NormalRoller 的双模式支持** (用户追加需求):
  - 参数 < 1: 概率判定 (如 0.5 → 50%概率返回1)
  - 参数 ≥ 1: 固定倍数 (如 25 → 必定返回25)

- **编译验证**: 0个错误,代码净减少28行 (101+ / 129-)

---

## 收获与反思

### ✅ 做得好的地方
- **方案讨论充分**: 提供了3个方案供用户选择,每个方案都说明了优缺点
- **命名优化**: `RollDrop` 比 `CalculateDrops` 更符合游戏开发术语("roll" for loot)
- **注释精准**: 只在关键的、易产生歧义的地方添加注释,不冗余
- **快速迭代**: 根据用户反馈(NormalRoller双模式)快速调整实现

### ⚠️ 可以改进的地方
- 最初误解了 `randomId` 的含义(以为是开关,实际是类型标识)
- 第一次方案设计时没有考虑到 `NormalRoller` 需要支持固定倍数模式

### 💡 新的认知
- **游戏掉落系统的设计模式**:
  - 触发判定和数量计算可以统一用"倍数"概念表达
  - 0作为特殊值表示"不触发",>0表示倍数,简洁且高效
- **命名的重要性**:
  - `RollDrop` vs `CalculateDrops`: 前者一眼看出是"单次",后者容易误解
  - `IRoller` vs `IDropRandomizer`: 前者短小易记
- **简化优于复杂**:
  - 用户多次强调"更简洁",最终选择了int而非结构体
  - 少即是多,3个类文件(IRoller, NormalRoller, RangeRoller)就解决了问题

### 📌 可复用的模式/最佳实践
- **策略模式 + 字典工厂**:
  ```csharp
  private static readonly Dictionary<string, IRoller> _rollers = new()
  {
      ["normal"] = new NormalRoller(),
      ["range"] = new RangeRoller(),
  };
  ```
  适用于需要根据配置动态选择算法的场景

- **用返回值表达多种语义**:
  - 0 = 失败/不触发
  - >0 = 成功且携带数值信息
  - 避免了复杂的返回类型

- **双模式设计**:
  - `NormalRoller` 根据参数范围(<1 或 ≥1)自动切换行为
  - 一个类支持两种用途,减少类数量

---

## 相关链接
- **代码提交**: `5bf49285a05b50e02d047f425be910147bb87e7b`
- **修改文件**:
  - `Server/src/Project.Grains/Config/Overrides/IRoller.cs` (新增)
  - `Server/src/Project.Grains/Config/Overrides/drop_group.cs` (重构)
  - `Server/src/Project.Grains/Config/Overrides/reward_pool.cs` (删除未使用代码)

---

## 标签
#CSharp #游戏开发 #掉落系统 #策略模式 #重构 #Orleans #.NET9
