# [2025-10-20] 装备模块强类型化与SOP建立

## 元信息
- 日期: 2025-10-20
- 项目: GuiRen (Server2)
- 主要问题: 将装备模块从弱类型转换为强类型,并建立可复用的SOP指导后续20+模块的重构工作

---

## 完整对话

### 对话1
**用户**: <从之前对话继续>

**Claude**: 我继续完成 SOP 创建计划中的任务。

<使用 TodoWrite 工具更新任务列表>

## 第 2 步: 为这类工作命名

根据我们完成的任务特征,我建议将这类工作命名为:

### 主要候选名称:

**1. "模块强类型化重构" (Module Strong-Typing Refactoring)**
- ✅ 准确描述核心目标: 从弱类型 Dictionary 转换为强类型类
- ✅ 突出重点: 类型安全
- ✅ 适用范围: 所有 PlayerState 模块 (20+ 个)

**2. "模块数据结构标准化" (Module Data Structure Standardization)**
- ✅ 强调结果: 标准化的数据结构
- ✅ 暗示质量提升
- ⚠️ 不够突出强类型这个核心特征

**3. "客户端-服务端数据契约实现" (Client-Server Data Contract Implementation)**
- ✅ 强调客户端兼容性验证
- ✅ 体现双向对齐
- ⚠️ 名称较长,不够简洁

### 推荐命名:

**"模块强类型化重构"** (简称: **模块强类型化**)

**理由:**
1. **简洁明了**: 一看就知道是把模块改成强类型
2. **技术准确**: 准确描述了从 `Dictionary<string, object>` 到强类型类的转换
3. **易于沟通**: 你说"我要做装备模块的强类型化",团队成员立即明白
4. **适用广泛**: 适用于所有 20+ 个模块的改造工作

---

### 相关术语定义:

为了让 SOP 更清晰,我建议同时定义以下配套术语:

- **模块类** (Module Class): 如 `EquipModule`, `BattleModule` 等业务模块类
- **数据类** (Data Class): 如 `EquipmentData`, `BattleData` 等细粒度数据对象
- **位字段打包** (Bit-Field Packing): 在单个整数中存储多个值的技术
- **零冗余设计** (Zero-Redundancy Design): 属性直接读写位字段,不存储中间变量
- **客户端对齐验证** (Client Alignment Verification): 通过对比客户端实现验证服务端正确性

---

这个命名是否符合你的预期?我可以基于这个命名继续完成后续的设计目标提炼和 SOP 编写。

<更新 TodoWrite: 命名任务完成,开始提炼设计目标>

---

### 对话2

## 第 3 步: 提炼设计目标和原则

基于装备模块重构的成功经验,我提炼出以下设计目标和原则:

---

### 核心设计目标

**1. 完全客户端兼容** (Client Compatibility First)
- JSON 序列化格式必须与客户端 100% 一致
- 字段名使用数字索引 (如 `"1"`, `"2"`, `"3"`)
- 位字段布局与客户端完全对齐 (bit layout, mask, shift)

**2. 零冗余数据存储** (Zero-Redundancy Storage)
- 不创建中间存储变量
- 属性的 get/set 直接读写序列化字段的位
- 内存占用与客户端保持一致

**3. 类型安全与可维护性** (Type Safety & Maintainability)
- 从 `Dictionary<string, object>` 转换为强类型类
- 编译时类型检查,避免运行时错误
- IntelliSense 支持,提高开发效率

**4. 业务逻辑封装** (Business Logic Encapsulation)
- 模块类提供业务方法 (Add, Remove, Find 等)
- 数据类提供便捷访问属性和工厂方法
- 隐藏位操作复杂性,暴露业务语义

---

### 设计原则

#### 原则 1: 保留原始字段名
```csharp
// ✅ 正确: 保留客户端字段名
[JsonPropertyName("1")]
public int base_value { get; set; }

[JsonPropertyName("2")]
public int distribution { get; set; }

// ❌ 错误: 修改字段名
public int BaseValue { get; set; }
public int Distribution { get; set; }
```

**理由**:
- 与客户端命名保持一致,减少理解成本
- JSON 序列化格式完全对齐
- 便于对照客户端代码验证

---

#### 原则 2: 属性直接操作位字段,不设中间变量
```csharp
// ✅ 正确: 零冗余设计
[JsonPropertyName("1")]
public int base_value { get; set; }

[JsonIgnore]
public int TemplateId
{
    get => (base_value >> 16) & 0x0FFF;
    set => base_value = (base_value & ~(0x0FFF << 16)) | ((value & 0x0FFF) << 16);
}

// ❌ 错误: 创建中间变量
private int _templateId;
public int TemplateId
{
    get => _templateId;
    set { _templateId = value; PackBaseValue(); }
}
```

**理由**:
- 避免数据冗余和同步问题
- 减少内存占用
- 确保序列化字段是唯一数据源

---

#### 原则 3: 定义常量明确位字段布局
```csharp
// 位掩码常量 (Bit Masks)
private const int NEW_MASK = unchecked((int)0x80000000);       // bit 31
private const int LOCK_MASK = 0x40000000;                      // bit 30
private const int TEMPLATE_ID_MASK = 0x0FFF;                   // bit 16-27 (12 bits)
private const int STARS_MASK = 0xFF;                           // bit 8-15 (8 bits)
private const int LEVEL_MASK = 0xFF;                           // bit 0-7 (8 bits)

// 位移量常量 (Bit Shifts)
private const int TEMPLATE_ID_SHIFT = 16;
private const int STARS_SHIFT = 8;
```

**理由**:
- 提高代码可读性和可维护性
- 便于验证与客户端的一致性
- 减少魔法数字 (magic numbers)

---

#### 原则 4: 使用 JsonIgnore 隔离业务属性
```csharp
// 序列化字段
[JsonPropertyName("1")]
public int base_value { get; set; }

// 业务访问属性 (不序列化)
[JsonIgnore]
public int TemplateId { get; set; }

[JsonIgnore]
public int Stars { get; set; }
```

**理由**:
- 明确区分序列化字段和业务属性
- 避免 JSON 中出现重复数据
- 保持 JSON 格式与客户端完全一致

---

#### 原则 5: 提供静态工厂方法创建对象
```csharp
public static EquipmentData Create(
    int templateId,
    int stars = 1,
    int level = 1,
    int distribution = 0,
    bool isNew = true,
    bool isLock = false)
{
    var equip = new EquipmentData
    {
        distribution = distribution,
        TemplateId = templateId,  // 使用属性 setter
        Stars = stars,
        Level = level,
        IsNew = isNew,
        IsLock = isLock
    };
    return equip;
}
```

**理由**:
- 提供清晰的对象创建接口
- 自动处理位字段打包
- 支持默认参数,简化调用

---

#### 原则 6: 业务方法封装在模块类中
```csharp
public class EquipModule
{
    public string AddEquipment(EquipmentData equipment)
    {
        var id = euid.ToString();
        el[id] = equipment;
        euid++;
        ec = el.Count;
        return id;
    }

    public bool RemoveEquipment(string equipId)
    {
        var removed = el.Remove(equipId);
        if (removed) ec = el.Count;
        return removed;
    }
}
```

**理由**:
- 集中管理业务逻辑
- 自动维护派生字段 (如 `ec`)
- 提供一致的操作接口

---

#### 原则 7: 通过测试验证客户端对齐
```csharp
// 手动计算期望值
int expected = (1 << 16) | (3 << 8) | 10 | unchecked((int)0x80000000);

// 验证实际值
Console.WriteLine($"base_value 匹配: {equip.base_value == expected}");

// JSON 序列化往返测试
var json = JsonSerializer.Serialize(equip);
var equip2 = JsonSerializer.Deserialize<EquipmentData>(json);
```

**理由**:
- 确保实现与客户端完全一致
- 尽早发现位字段布局错误
- 验证序列化/反序列化正确性

---

### 质量标准

**必须满足:**
- ✅ 编译通过 (0 个错误, 0 个警告)
- ✅ JSON 格式与客户端 100% 一致
- ✅ 位字段布局与客户端完全对齐
- ✅ 测试覆盖所有序列化字段
- ✅ 代码注释说明位字段布局

**建议达到:**
- ✅ 提供完整的业务方法 (CRUD)
- ✅ 提供便捷的查询/筛选方法
- ✅ 提供工厂方法简化对象创建
- ✅ 使用 C# 13 最新语法特性

---

这些设计目标和原则是否准确总结了我们的成功经验?我接下来会基于这些原则整理详细的 SOP 操作流程。

---

### 对话3
**用户**: 好

**Claude**: <更新 TodoWrite: 设计目标完成,开始整理SOP>

## 第 4 步: 整理标准操作流程 (SOP)

---

# 模块强类型化重构 SOP

## 适用场景

将 PlayerState 中的弱类型模块 (`Dictionary<string, object>`) 转换为强类型类,确保与客户端数据结构 100% 兼容。

---

## 阶段 1: 理解现有实现

### 步骤 1.1: 查看客户端模块定义

**目标**: 理解数据结构和字段语义

**操作**:
```bash
# 查找客户端模块文件
find Client/WuShuang2/Assets/LuaScript/module/remote -name "*{模块名}_module.lua"

# 查看模块定义
cat Client/WuShuang2/Assets/LuaScript/common/module_def.lua | grep -A 20 "{模块名}"
```

**需要确认**:
- 模块包含哪些字段
- 字段的数据类型 (number, string, list, map)
- 字段的业务语义 (如 `ec` = equipment count)
- 是否有嵌套的复杂对象

**示例 (装备模块)**:
```lua
-- module_def.lua
ModuleDef.EQUIP = {
    ac = 0,           -- additional capacity
    ec = 0,           -- equipment count
    el = {},          -- equipment list (map)
    euid = 1,         -- equipment unique id
}
```

---

### 步骤 1.2: 查看客户端数据枚举定义

**目标**: 确认 JSON 序列化格式 (字段索引)

**操作**:
```bash
cat Client/WuShuang2/Assets/LuaScript/common/data_enum.lua | grep -A 10 "{数据对象名}"
```

**需要确认**:
- 模块级别的字段索引 (如 ac=1, ec=2, el=3, euid=4)
- 嵌套对象的字段索引 (如 equipment 对象的字段索引)

**示例 (装备数据)**:
```lua
-- data_enum.lua
DataEnum:AddEnum("equipment", {
    base_value = acc(1),      -- 索引 1
    distribution = acc(),     -- 索引 2
    attr_list = acc(),        -- 索引 3
    uuid = acc(),             -- 索引 4 (unused)
    ability = acc(),          -- 索引 5
})
```

---

### 步骤 1.3: 查看客户端位字段处理逻辑

**目标**: 理解位字段的打包/解包逻辑

**仅当字段类型为 `number` 且客户端有位操作代码时需要此步骤**

**操作**:
```bash
# 搜索位掩码常量定义
grep -n "MASK\|0x[0-9A-F]" Client/WuShuang2/Assets/LuaScript/module/remote/{模块名}_module.lua
```

**需要确认**:
- 每个位字段的布局 (起始位, 长度, 掩码)
- 位字段的数据范围 (如 0-255, 0-4095)
- 特殊标志位 (如最高位表示 is_new)

**示例 (装备 base_value)**:
```lua
local NEW_MASK  = 0x80000000  -- bit 31
local LOCK_MASK = 0x40000000  -- bit 30
local TEMPLATE_ID_MASK = 0x0FFF  -- bit 16-27

local function ParseEquipBaseValue(base_value)
    local template_id = (base_value >> 16) & TEMPLATE_ID_MASK
    local stars = (base_value >> 8) & 0xFF
    local level = base_value & 0xFF
    local is_new = (base_value & NEW_MASK) ~= 0
    local is_lock = (base_value & LOCK_MASK) ~= 0
    return template_id, stars, level, is_new, is_lock
end
```

**整理位字段布局表**:
| 字段 | 位范围 | 掩码 | 数据范围 |
|------|--------|------|----------|
| level | 0-7 | 0xFF | 0-255 |
| stars | 8-15 | 0xFF | 0-255 |
| template_id | 16-27 | 0x0FFF | 0-4095 |
| is_lock | 30 | 0x40000000 | bool |
| is_new | 31 | 0x80000000 | bool |

---

### 步骤 1.4: 查看服务端现有代码

**目标**: 理解当前的弱类型实现

**操作**:
```bash
# 查看模块类
cat src/Project.Grains/Player/Modules/{模块名}Module.cs

# 查看消息处理器
cat src/Project.Grains/Player/MessageHandler/PlayerGrain.{模块名}.cs
```

**需要确认**:
- 模块类的字段名和类型
- 现有的业务方法
- 消息处理器如何访问数据

---

## 阶段 2: 设计强类型结构

### 步骤 2.1: 设计模块类

**模板**:
```csharp
/// <summary>
/// {模块中文名}模块
/// 对应客户端 module_def.lua 中的 {MODULE_NAME} 模块
/// </summary>
public class {ModuleName}Module
{
    /// <summary>
    /// {字段1中文说明} ({字段1英文全称})
    /// </summary>
    [JsonPropertyName("1")]
    public {Type1} {field1} { get; set; } = {默认值};

    /// <summary>
    /// {字段2中文说明} ({字段2英文全称})
    /// </summary>
    [JsonPropertyName("2")]
    public {Type2} {field2} { get; set; } = {默认值};

    // ... 其他字段

    // ===== 业务方法 =====
}
```

**注意事项**:
- JsonPropertyName 使用字符串数字索引 ("1", "2", "3")
- 字段名保持与客户端完全一致 (如 `ac`, `ec`, `el`)
- 注释说明字段含义和英文全称
- 默认值与客户端 module_def 保持一致

---

### 步骤 2.2: 设计数据类 (如有嵌套对象)

**适用场景**: 模块字段中包含复杂对象 (如装备列表中的单个装备)

**模板**:
```csharp
/// <summary>
/// {数据对象中文名}
/// 对应客户端 DataEnum 中的 "{data_enum_name}" 定义
/// </summary>
public class {DataName}Data
{
    // ===== 位字段常量定义 =====

    private const int {FIELD}_MASK = 0x{HEX};
    private const int {FIELD}_SHIFT = {N};

    // ===== 序列化字段 =====

    [JsonPropertyName("1")]
    public int {packed_field} { get; set; }

    // ===== 便捷访问属性 (零冗余) =====

    [JsonIgnore]
    public int {BusinessField}
    {
        get => ({packed_field} >> {SHIFT}) & {MASK};
        set => {packed_field} = ({packed_field} & ~({MASK} << {SHIFT}))
                              | ((value & {MASK}) << {SHIFT});
    }

    // ===== 工厂方法 =====

    public static {DataName}Data Create(...) { }
}
```

**位字段属性模板 (bool 类型)**:
```csharp
[JsonIgnore]
public bool IsNew
{
    get => (base_value & NEW_MASK) != 0;
    set
    {
        if (value)
            base_value |= NEW_MASK;
        else
            base_value &= ~NEW_MASK;
    }
}
```

---

### 步骤 2.3: 列出要创建/修改的文件清单

**示例**:
```
修改:
- src/Project.Grains/Player/Modules/EquipModule.cs
  - 修改 el 字段类型: Dictionary<string, object> → Dictionary<string, EquipmentData>
  - 添加业务方法: AddEquipment, RemoveEquipment, GetEquipment 等

新建:
- src/Project.Grains/Player/Modules/Equip/EquipmentData.cs
  - 定义 EquipmentData 类
  - 实现位字段属性
  - 实现工厂方法和辅助方法
```

---

## 阶段 3: 实现代码

### 步骤 3.1: 创建数据类 (如有)

**操作**:
1. 创建文件: `src/Project.Grains/Player/Modules/{模块名}/{DataName}Data.cs`
2. 定义位字段常量
3. 定义序列化字段
4. 实现便捷访问属性 (零冗余设计)
5. 实现工厂方法
6. 实现业务辅助方法 (如 Clone, GetAttributes 等)

**验证**:
- 编译通过
- 所有属性都有 get/set
- JsonPropertyName 索引正确
- JsonIgnore 标记正确

---

### 步骤 3.2: 修改模块类

**操作**:
1. 修改复杂字段的类型 (如 `Dictionary<string, object>` → `Dictionary<string, EquipmentData>`)
2. 添加业务方法:
   - Get/Has 方法 (查询)
   - Add 方法 (创建, 自动维护 count 和 id)
   - Remove 方法 (删除, 自动维护 count)
   - Find 方法 (筛选)
3. 添加辅助方法 (如 GetCapacity, IsFull 等)

**验证**:
- 编译通过
- 业务方法自动维护派生字段 (如 `ec = el.Count`)

---

### 步骤 3.3: 编译并修复错误

**操作**:
```powershell
dotnet build src/Project.Grains/Project.Grains.csproj
```

**常见错误**:
1. **类型不匹配**: `Dictionary<string, object>` 访问需要强制转换
   - 修改消息处理器中的访问代码
2. **JsonPropertyName 冲突**: 业务属性忘记标记 JsonIgnore
3. **位操作错误**: 掩码或移位错误
   - 对照客户端代码仔细检查

**目标**: 0 个错误, 0 个警告

---

## 阶段 4: 验证实现

### 步骤 4.1: 创建测试项目

**操作**:
```powershell
# 创建测试项目
dotnet new console -n {ModuleName}Test -o test/{ModuleName}Test

# 添加项目引用
cd test/{ModuleName}Test
dotnet add reference ../../src/Project.Grains/Project.Grains.csproj

# 添加到解决方案
cd ../../
dotnet sln add test/{ModuleName}Test/{ModuleName}Test.csproj
```

---

### 步骤 4.2: 编写验证测试

**测试内容**:

**1. 属性验证**:
```csharp
var data = {DataName}Data.Create(...);
Console.WriteLine($"{Field}: {data.{Field}} (期望: {expected})");
```

**2. 位字段原始值验证**:
```csharp
int expected = (value1 << shift1) | (value2 << shift2) | ...;
Console.WriteLine($"base_value 匹配: {data.base_value == expected}");
```

**3. JSON 序列化验证**:
```csharp
var json = JsonSerializer.Serialize(data, new JsonSerializerOptions { WriteIndented = true });
Console.WriteLine(json);

// 检查 JSON 格式
// 期望: {"1": 123, "2": 456, ...}
```

**4. JSON 反序列化验证**:
```csharp
var data2 = JsonSerializer.Deserialize<{DataName}Data>(json);
bool allMatch = true;
allMatch &= Check("Field1", data2.Field1, expected1);
allMatch &= Check("Field2", data2.Field2, expected2);
Console.WriteLine($"所有字段验证: {(allMatch ? "✅ 通过" : "❌ 失败")}");
```

**5. 模块序列化验证**:
```csharp
var module = new {ModuleName}Module();
var id = module.Add{DataName}(data);
var moduleJson = JsonSerializer.Serialize(module);
var module2 = JsonSerializer.Deserialize<{ModuleName}Module>(moduleJson);
```

---

### 步骤 4.3: 运行测试

**操作**:
```powershell
cd test/{ModuleName}Test
dotnet run
```

**期望结果**:
- ✅ 所有属性值匹配
- ✅ 位字段原始值匹配
- ✅ JSON 格式正确 (数字索引)
- ✅ 反序列化后所有字段匹配
- ✅ 模块序列化往返成功

---

### 步骤 4.4: 对照客户端验证

**操作**:
1. 手动计算位字段期望值,与测试输出对比
2. 将 JSON 输出与客户端格式对比
3. 检查位字段布局表与客户端代码一致

**位字段布局对照表**:
| 字段 | 客户端位范围 | 服务端位范围 | 匹配 |
|------|--------------|--------------|------|
| level | 0-7 | 0-7 | ✅ |
| stars | 8-15 | 8-15 | ✅ |
| template_id | 16-27 | 16-27 | ✅ |

---

## 阶段 5: 最终检查

### 验证清单

**代码质量**:
- [ ] 编译通过 (0 个错误, 0 个警告)
- [ ] 字段名与客户端完全一致
- [ ] JsonPropertyName 索引与客户端对齐
- [ ] 位字段布局与客户端完全一致
- [ ] 使用零冗余设计 (无中间变量)
- [ ] 所有位字段常量有注释说明
- [ ] 业务方法自动维护派生字段

**功能验证**:
- [ ] 所有属性测试通过
- [ ] 位字段原始值测试通过
- [ ] JSON 序列化格式正确
- [ ] JSON 反序列化测试通过
- [ ] 模块序列化往返测试通过

**文档**:
- [ ] 类和字段有完整注释
- [ ] 位字段布局有注释说明
- [ ] 测试项目已添加到解决方案

---

## 常见问题处理

### 问题 1: JSON 中出现了业务属性

**现象**:
```json
{
  "1": 123456,
  "TemplateId": 1,  // ❌ 不应该出现
  "Stars": 3        // ❌ 不应该出现
}
```

**原因**: 业务属性忘记标记 `[JsonIgnore]`

**解决**:
```csharp
[JsonIgnore]
public int TemplateId { get; set; }
```

---

### 问题 2: 位字段值不匹配

**现象**: 测试输出的 `base_value` 与手动计算不一致

**排查步骤**:
1. 检查掩码常量是否正确
2. 检查移位量是否正确
3. 检查 set 操作的位清除逻辑
4. 对照客户端代码逐位验证

**调试技巧**:
```csharp
Console.WriteLine($"base_value: {data.base_value} (0x{data.base_value:X8})");
Console.WriteLine($"期望值: {expected} (0x{expected:X8})");
```

---

### 问题 3: 反序列化后属性值错误

**原因**: 属性的 get 逻辑错误

**排查**:
1. 检查掩码是否正确
2. 检查移位方向 (左移 vs 右移)
3. 检查是否处理了符号扩展 (对于最高位)

---

## 参考示例

**完整示例**: 装备模块强类型化
- 数据类: `src/Project.Grains/Player/Modules/Equip/EquipmentData.cs`
- 模块类: `src/Project.Grains/Player/Modules/EquipModule.cs`
- 测试项目: `test/EquipTest/Program.cs`

---

<更新 TodoWrite: SOP 整理完成,开始编写验证检查清单>

---

### 对话4 (继续)

## 第 5 步: 编写验证检查清单

---

# 模块强类型化验证检查清单

## 使用说明

在完成模块强类型化重构后,按照此清单逐项检查,确保实现质量。所有项目必须通过 (✅) 才能提交代码。

---

## 第 1 部分: 代码结构检查

### 1.1 文件组织

- [ ] 数据类文件已创建 (如需要): `src/Project.Grains/Player/Modules/{模块名}/{DataName}Data.cs`
- [ ] 模块类文件已修改: `src/Project.Grains/Player/Modules/{ModuleName}Module.cs`
- [ ] 测试项目已创建: `test/{ModuleName}Test/`
- [ ] 测试项目已添加到解决方案: `dotnet sln list` 可看到

### 1.2 命名空间和引用

- [ ] 所有文件使用 `namespace Project.Grains;`
- [ ] 引用了 `System.Text.Json.Serialization`
- [ ] 数据类和模块类在同一命名空间

---

## 第 2 部分: 模块类检查

### 2.1 字段定义

- [ ] 所有字段名与客户端完全一致 (如 `ac`, `ec`, `el`, `euid`)
- [ ] `[JsonPropertyName]` 使用字符串数字索引 ("1", "2", "3", ...)
- [ ] 索引顺序与客户端 module_def.lua 一致
- [ ] 复杂对象使用强类型 (如 `Dictionary<string, EquipmentData>`)
- [ ] 字段有默认值,与客户端 module_def 一致

### 2.2 注释文档

- [ ] 类有 `<summary>` 注释,说明对应的客户端模块
- [ ] 每个字段有注释,说明中文含义和英文全称
- [ ] 业务方法有注释说明用途

### 2.3 业务方法

- [ ] 提供 Get 方法 (如 `GetEquipment(string id)`)
- [ ] 提供 Has 方法 (如 `HasEquipment(string id)`)
- [ ] 提供 Add 方法,自动维护 count 和 id (如 `AddEquipment(data)`)
- [ ] 提供 Remove 方法,自动维护 count (如 `RemoveEquipment(string id)`)
- [ ] 提供批量操作方法 (如 `AddEquipments`, `RemoveEquipments`)
- [ ] 提供辅助查询方法 (如 `GetCapacity`, `IsFull`, `FindEquipments`)

---

## 第 3 部分: 数据类检查 (如有嵌套对象)

### 3.1 位字段常量

- [ ] 所有掩码常量已定义 (如 `NEW_MASK`, `TEMPLATE_ID_MASK`)
- [ ] 所有移位常量已定义 (如 `TEMPLATE_ID_SHIFT`)
- [ ] 常量有注释说明位范围和用途 (如 `// bit 31` 或 `// bit 16-27 (12 bits)`)
- [ ] 掩码值与客户端完全一致

### 3.2 序列化字段

- [ ] 所有序列化字段有 `[JsonPropertyName]` 标记
- [ ] 索引与客户端 DataEnum 定义一致
- [ ] 字段名与客户端完全一致 (如 `base_value`, `distribution`, `attr_list`, `ability`)
- [ ] 字段类型正确 (int, List<int>, etc.)

### 3.3 业务属性 (零冗余设计)

- [ ] 所有业务属性标记了 `[JsonIgnore]`
- [ ] 属性的 get 直接读取序列化字段的位
- [ ] 属性的 set 直接修改序列化字段的位
- [ ] **没有**中间存储变量 (如 `private int _templateId`)
- [ ] bool 属性正确处理掩码位 (if/else 或三元运算符)
- [ ] int 属性正确处理掩码和移位

### 3.4 位操作正确性

**对于每个业务属性,验证以下公式**:

**Get 操作**:
```csharp
// 整数字段
value = (packed_field >> SHIFT) & MASK;

// bool 字段
value = (packed_field & MASK) != 0;
```

**Set 操作**:
```csharp
// 整数字段
packed_field = (packed_field & ~(MASK << SHIFT))    // 清除原值
             | ((value & MASK) << SHIFT);           // 设置新值

// bool 字段 (true)
packed_field |= MASK;

// bool 字段 (false)
packed_field &= ~MASK;
```

- [ ] 所有 get 操作使用了正确的移位和掩码
- [ ] 所有 set 操作先清除原值,再设置新值
- [ ] bool set 操作使用了 if/else 分支

### 3.5 工厂方法和辅助方法

- [ ] 提供 `Create` 静态工厂方法
- [ ] `Create` 方法使用业务属性赋值 (非直接赋值序列化字段)
- [ ] 提供 `Clone` 方法 (如需要)
- [ ] 提供列表字段的解析方法 (如 `GetAttributes()`)
- [ ] 提供列表字段的修改方法 (如 `AddAttribute`, `UpdateAttribute`, `RemoveAttribute`)

---

## 第 4 部分: 编译检查

### 4.1 编译结果

```powershell
dotnet build src/Project.Grains/Project.Grains.csproj
```

- [ ] 0 个错误
- [ ] 0 个警告
- [ ] 编译成功输出 `.dll` 文件

### 4.2 消息处理器兼容性

- [ ] 所有访问模块数据的消息处理器代码已更新
- [ ] 移除了对 `Dictionary<string, object>` 的强制转换
- [ ] 使用了新的强类型方法

---

## 第 5 部分: 测试验证

### 5.1 测试项目结构

- [ ] 测试项目可编译通过
- [ ] 测试项目引用了 `Project.Grains`
- [ ] 测试项目使用 `System.Text.Json`

### 5.2 属性测试

**运行测试**:
```powershell
cd test/{ModuleName}Test
dotnet run
```

- [ ] 所有业务属性值正确 (与期望值匹配)
- [ ] 输出格式: `{Field}: {actual} (期望: {expected}) - ✅`

### 5.3 位字段原始值测试

- [ ] 手动计算了位字段期望值
- [ ] 实际值与期望值匹配
- [ ] 输出了十六进制格式便于调试 (如 `0x8001030A`)

### 5.4 JSON 序列化测试

**检查 JSON 格式**:
```json
{
  "1": 12345,
  "2": 67890,
  "3": [512, 768]
}
```

- [ ] 所有 key 是字符串数字索引
- [ ] 没有出现业务属性名 (如 "TemplateId")
- [ ] 值的类型正确 (number, array, object)
- [ ] JSON 格式与客户端发送的格式一致

### 5.5 JSON 反序列化测试

- [ ] 反序列化成功,没有抛出异常
- [ ] 所有业务属性值与原对象匹配
- [ ] 所有序列化字段值与原对象匹配

### 5.6 模块序列化测试

- [ ] 模块序列化为 JSON 成功
- [ ] 模块反序列化成功
- [ ] 反序列化后模块字段值正确 (count, id, list)
- [ ] 反序列化后嵌套对象可正常访问

---

## 第 6 部分: 客户端对齐验证

### 6.1 字段名对齐

**对照表**:
| 客户端 module_def 字段名 | 服务端字段名 | 匹配 |
|--------------------------|--------------|------|
| ac | ac | ✅ |
| ec | ec | ✅ |
| el | el | ✅ |
| euid | euid | ✅ |

- [ ] 所有字段名完全一致

### 6.2 字段索引对齐

**对照表**:
| 客户端 DataEnum 字段 | 客户端索引 | 服务端 JsonPropertyName | 匹配 |
|----------------------|------------|-------------------------|------|
| base_value | 1 | "1" | ✅ |
| distribution | 2 | "2" | ✅ |
| attr_list | 3 | "3" | ✅ |
| ability | 5 | "5" | ✅ |

- [ ] 所有索引完全一致

### 6.3 位字段布局对齐

**对照表**:
| 字段 | 客户端位范围 | 客户端掩码 | 服务端位范围 | 服务端掩码 | 匹配 |
|------|--------------|------------|--------------|------------|------|
| level | 0-7 | 0xFF | 0-7 | 0xFF | ✅ |
| stars | 8-15 | 0xFF | 8-15 | 0xFF | ✅ |
| template_id | 16-27 | 0x0FFF | 16-27 | 0x0FFF | ✅ |
| is_lock | 30 | 0x40000000 | 30 | 0x40000000 | ✅ |
| is_new | 31 | 0x80000000 | 0x80000000 | 31 | ✅ |

- [ ] 所有位字段布局完全一致

### 6.4 实际数据对比

**手动计算示例**:
```
输入: templateId=1, stars=3, level=10, isNew=true, isLock=false
期望 base_value = (1 << 16) | (3 << 8) | 10 | 0x80000000
                = 0x00010000 | 0x00000300 | 0x0000000A | 0x80000000
                = 0x8001030A
                = -2147417334 (signed int)
```

- [ ] 手动计算与测试输出匹配
- [ ] 对比了至少 2 组不同的测试数据

---

## 第 7 部分: 代码质量检查

### 7.1 C# 13 语法

- [ ] 使用 file-scoped namespace: `namespace Project.Grains;`
- [ ] 使用 target-typed new: `new()` 代替 `new List<int>()`
- [ ] 使用属性初始化器: `{ Field = value }`
- [ ] 使用表达式主体成员 (简单方法): `=> expression`

### 7.2 代码风格

- [ ] 字段名使用客户端风格 (snake_case, 如 `base_value`)
- [ ] 业务属性使用 PascalCase (如 `TemplateId`)
- [ ] 私有常量使用 UPPER_CASE (如 `TEMPLATE_ID_MASK`)
- [ ] 注释清晰,说明了位字段布局

### 7.3 异常处理

- [ ] 业务方法有空值检查 (如 `TryGetValue`)
- [ ] 边界检查正确 (如索引越界检查)
- [ ] 返回可空类型 (如 `EquipmentData?`)

---

## 第 8 部分: 文档检查

### 8.1 代码注释

- [ ] 类有 `<summary>` 说明对应客户端定义
- [ ] 位字段常量有注释说明位范围
- [ ] 复杂业务逻辑有注释说明

### 8.2 测试输出

- [ ] 测试输出结构清晰,分段显示
- [ ] 每个验证项有 ✅/❌ 标记
- [ ] 输出了完整的 JSON 示例

---

## 提交前最终确认

- [ ] **所有**上述检查项均通过 (✅)
- [ ] 测试运行输出保存到测试项目注释中 (可选)
- [ ] 代码已格式化 (`dotnet format`)
- [ ] 准备好提交信息,说明具体改动

**提交信息模板**:
```
将 {模块名} 模块从弱类型转换为强类型 - 提升类型安全性和开发效率

- 创建 {DataName}Data 类,实现零冗余位字段操作
- 修改 {ModuleName}Module 使用强类型 Dictionary
- 添加业务方法: Add, Remove, Get, Find 等
- 通过测试验证与客户端 100% 兼容
- 位字段布局与客户端完全对齐
```

---

<更新 TodoWrite: 检查清单完成,开始写入 CLAUDE.md>

---

### 对话5
<读取 CLAUDE.md 文件>

<编辑 CLAUDE.md,将完整的 SOP 添加到文件末尾>

<更新 TodoWrite: 所有任务完成>

完成!我已经将"模块强类型化重构 SOP"成功写入项目的 CLAUDE.md 文件。

## 总结

我完成了以下所有任务:

1. ✅ **总结任务流程**: 分析了整个装备模块重构的完整过程
2. ✅ **命名工作**: 将这类工作命名为 **"模块强类型化重构"**
3. ✅ **提炼设计原则**: 总结了 5 大核心设计原则和质量标准
4. ✅ **整理 SOP**: 创建了完整的 4 阶段标准操作流程
5. ✅ **编写检查清单**: 提供了详细的验证检查清单
6. ✅ **写入 CLAUDE.md**: 将完整的 SOP 添加到项目文档中

**SOP 包含内容**:
- **概述**: 明确适用场景和核心原则
- **阶段 1**: 理解现有实现 (客户端模块定义、数据枚举、位字段逻辑)
- **阶段 2**: 设计强类型结构 (模块类模板、数据类模板)
- **阶段 3**: 实现代码 (创建数据类、修改模块类、编译修复)
- **阶段 4**: 验证实现 (创建测试、编写测试、运行验证、对照客户端)
- **设计原则**: 5 大核心原则的代码示例
- **验证检查清单**: 代码结构、编译、测试、客户端对齐的完整检查项
- **参考示例**: 指向装备模块的实际实现代码

这个 SOP 现在可以指导你处理后面的 20+ 个模块重构工作,确保每个模块都遵循相同的高质量标准和流程。

---

### 对话6
**用户**: 有了这个,我之后做类似的工作的时候是不是只需要说 针对某个模块做强类型化工作就行了。而不用再强调参考客户端之类的要求?

**Claude**: 是的,完全正确!

有了这个 SOP 之后,你以后只需要说:

> "对 XXX 模块做强类型化"

或者

> "强类型化 XXX 模块"

我就会自动:
1. 阅读项目 CLAUDE.md 中的"模块强类型化重构 SOP"
2. 按照 SOP 的 4 个阶段执行:
   - 查看客户端代码 (module_def.lua, data_enum.lua, 位字段逻辑)
   - 设计强类型结构
   - 实现代码 (零冗余设计)
   - 创建测试验证 (对照客户端)
3. 遵循所有设计原则 (保留字段名、零冗余、位字段常量等)
4. 使用验证检查清单确保质量

**你不需要再重复说明**:
- ❌ "参考客户端实现"
- ❌ "保持字段名一致"
- ❌ "使用零冗余设计"
- ❌ "创建测试验证"
- ❌ "位字段直接操作,不要中间变量"

**这些都已经内置在 SOP 中了**。

---

**示例对话**:

**你**: "对英雄模块做强类型化"

**我**:
- 查看 `module_def.lua` 中的 HERO 模块定义
- 查看 `data_enum.lua` 中的 hero 数据枚举
- 查看 `hero_module.lua` 中的位字段逻辑
- 设计 HeroModule 和 HeroData 类
- 实现代码并编译
- 创建 HeroTest 测试项目验证

---

这就是 SOP 的价值:将成功经验固化为标准流程,减少沟通成本,提高执行效率和质量一致性。对于你接下来的 20+ 个模块,这会大大加快工作速度! 🎯

---

### 对话7
**用户**: 提交代码

**Claude**: <查看 git 状态>

<查看 CLAUDE.md 的修改差异>

现在我将提交代码。根据修改内容,准备提交信息:

<执行 git commit,提交装备模块强类型化和 SOP>

<查看提交详情>

完成! ✅ 代码已成功提交。

## 提交摘要

**Commit**: `2f55f40`

**修改内容**:
1. **装备模块强类型化** (3 个文件):
   - 新建 `EquipmentData.cs` (347 行) - 零冗余位字段操作
   - 修改 `EquipModule.cs` (新增 138 行) - 强类型字段和业务方法
   - 新建 `EquipTest` 测试项目 (122 行) - 验证客户端兼容性

2. **模块强类型化重构 SOP** (1 个文件):
   - 修改 `CLAUDE.md` (新增 451 行) - 完整的标准操作流程

3. **解决方案配置** (1 个文件):
   - 修改 `Project.Server.sln` - 添加 EquipTest 测试项目

**总计**: 6 个文件, +1236 行代码

---

现在你可以 `git push` 推送到远程仓库,或者继续处理下一个模块的强类型化工作! 🎯

---

### 对话8
**用户**: 帮我看一下我还有多少个模块没有强类型化

**Claude**: <读取 PlayerState.cs 查看所有模块定义>

<使用 Glob 查找所有模块文件>

<检查 BattleModule, EconomicModule, HeroModule 的实现>

<搜索所有使用弱类型的模块>

<系统地检查每个模块的弱类型字段>

根据检查结果,以下是**需要强类型化的模块清单**:

## 需要强类型化的模块 (共 13 个)

| # | 模块名 | 文件 | 弱类型字段 | 备注 |
|---|--------|------|-----------|------|
| 1 | 活动模块 | ActiveModule.cs | `dl` (Dictionary<string, object>) | 活动数据列表 |
| 2 | 冒险模块 | AdventureModule.cs | `tower` (Dictionary<string, object>) | 塔数据 |
| 3 | 拍卖模块 | AuctionModule.cs | `al` (List<object>)<br>`bl` (List<object>) | 拍卖列表<br>购买列表 |
| 4 | 战斗通行证模块 | BattlePassModule.cs | `bl` (List<object>)<br>`rl` (List<object>) | 战斗通行证列表<br>退款物品列表 |
| 5 | 祝福模块 | BlessModule.cs | `bl` (Dictionary<string, object>) | 祝福列表 |
| 6 | 自定义数据模块 | CustomDataModule.cs | `d` (Dictionary<string, object>) | 自定义数据 |
| 7 | 邀请模块 | InviteModule.cs | `il` (List<object>) | 被邀请者列表 |
| 8 | 邮件模块 | MailModule.cs | `ml` (List<object>) | 邮件列表 |
| 9 | 宠物模块 | PetModule.cs | `epl` (List<object>)<br>`pl` (Dictionary<string, object>) | 上阵宠物列表<br>宠物列表 |
| 10 | 玩家模块 | PlayerModule.cs | `cl` (List<object>) | 领取记录列表 |
| 11 | 购买模块 | PurchaseModule.cs | `bil` (Dictionary<string, object>)<br>`tdp` (Dictionary<string, object>) | 账单列表<br>第三方支付数据 |
| 12 | 商店模块 | ShopModule.cs | `tph` (Dictionary<string, object>)<br>`wph` (Dictionary<string, object>) | 今日购买历史<br>本周购买历史 |
| 13 | VIP模块 | VipModule.cs | `cl` (List<object>) | 领取状态列表 |
| 14 | 周常任务模块 | WeeklyTaskModule.cs | `cl` (Dictionary<string, object>)<br>`isl` (Dictionary<string, object>) | 领取状态<br>完成状态 |

---

## 已完成强类型化的模块 (共 3 个)

| # | 模块名 | 文件 | 状态 |
|---|--------|------|------|
| 1 | 装备模块 | EquipModule.cs | ✅ 已完成 (含 EquipmentData) |
| 2 | 战斗模块 | BattleModule.cs | ✅ 已完成 (含 RoomDropData) |
| 3 | 经济模块 | EconomicModule.cs | ✅ 已完成 (无嵌套对象) |

---

## 无需强类型化的模块 (共 16 个)

这些模块没有使用 `Dictionary<string, object>` 或 `List<object>`,已经是强类型或简单类型:

- AchievementModule (成就模块)
- ActivityTaskModule (活动任务模块)
- AimModule (目标模块)
- BoxModule (宝箱模块)
- BranchModule (分支模块)
- DailyTaskModule (每日任务模块)
- EnergyModule (能量模块)
- FrontLineModule (前线模块)
- GmModule (GM模块)
- GuideModule (引导模块)
- HeroModule (英雄模块) - **需要确认 HeroData 是否需要 JsonPropertyName**
- HunterModule (猎人模块)
- MonthCardModule (月卡模块)
- PigBankModule (存钱罐模块)
- PlayerModule (玩家模块) - 除了 `cl` 字段
- TechnologyModule (科技模块)

---

## 总结

**你还有 13-14 个模块需要强类型化**,具体取决于:
- **13 个**模块有明确的弱类型字段需要转换
- **HeroModule** 需要确认 `HeroData` 是否需要添加 JsonPropertyName

之前你说"还有二十多个模块要处理",实际上需要强类型化的模块是 **13 个**,比预期少一些! 🎉

---

### 对话9
**用户**: 备份对话

**Claude**: 好的,我现在为你备份对话。

<检查备份目录>

现在我开始备份对话。首先保存完整的原始对话:

<正在创建此文件...>
