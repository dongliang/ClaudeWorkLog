# [2025-01-21] 添加服务器消息开发标准化工作流程到项目CLAUDE.md

## 元信息
- 日期: 2025-01-21
- 项目: GuiRen (鬼刃游戏服务器)
- 主要问题: 将标准化的服务器消息开发工作流程文档整合到项目的 CLAUDE.md 中

---

## 完整对话

### 对话1
**用户**:
```
🎯 服务器消息开发标准化工作流程

  📖 核心理念

  三层分离原则:
  - 静态层: 配置数据预处理 (启动时一次性计算)
  - 业务层: 模块业务逻辑 (封装状态修改和计算)
  - 胶水层: 消息处理器 (连接请求、业务、响应)

  自底向上原则: 先依赖后业务,确保所有依赖在使用前就绪

  ---
  📋 总体流程图

  ┌─────────────────────────────────────────┐
  │    需求来源: MessageHandler 中的消息    │
  └──────────────────┬──────────────────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │   指令0: 前置检查    │
          └──────────┬───────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │   指令1: 常量对齐    │ ◄─── 步骤1
          └──────────┬───────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │ 指令2: 配置预处理    │ ◄─── 步骤2
          └──────────┬───────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │ 指令3: 模块强类型化  │ ◄─── 步骤3
          └──────────┬───────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │ 指令4: 实现消息函数  │ ◄─── 步骤4
          └──────────┬───────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │   指令5: 编译验证    │
          └──────────┬───────────┘
                     │
                     ↓
          ┌──────────────────────┐
          │   指令6: 客户端测试  │
          └──────────────────────┘

  ---
  🔧 指令清单

  指令0: 前置检查 (Pre-Check)

  目标: 理解消息需求和客户端实现

  执行步骤:

  1. 查看协议定义:
     - 文件: c2s.proto, s2c.proto
     - 确认: request 参数, response 字段

  2. 查看客户端发送时机:
     - 搜索: grep -n "session:call.*{消息名}" ../Client/WuShuang2/**/*.lua
     - 确认: 何时发送, 发送什么参数

  3. 查看客户端数据消费逻辑:
     - 重点: 客户端如何消费 sync_list 同步的模块数据
     - 搜索: grep -n "{模块名}\.{字段名}" ../Client/WuShuang2/**/*.lua
     - 确认: UI 刷新, 战斗计算, 事件触发等消费场景

  4. 确认客户端接收处理:
     - 搜索: grep -n "function.*on_{消息名}" ../Client/WuShuang2/**/*.lua
     - 确认: 接收后做了什么 (通常很轻量)

  输出:
  - 理解消息的业务含义
  - 理解请求参数含义
  - 理解响应字段用途
  - 理解客户端如何消费数据

  关键认知:
  游戏大部分数据通过 sync_list 自动同步,而非显式 response 字段。
  要理解客户端"消费"数据的逻辑,而非仅看接收消息的处理。

  ---
  指令1: 常量对齐 (Constant Alignment)

  触发条件: 需要使用枚举值、ID、魔法数字

  目标: 确保服务端常量与客户端完全一致

  执行步骤:

  1. 查找客户端常量:
     - glob: "../Client/WuShuang2/**/{关键词}_def.lua"
     - grep: "{常量名}" ../Client/WuShuang2/Assets/LuaScript/common/

  2. 创建服务端常量类:
     - 路径: src/Project.Grains/Common/{功能名}Constant.cs
     - 命名: {功能名}Id (ID类) / {功能名}Type (枚举类)

  3. 验证对齐:
     - 对照客户端逐一检查常量值
     - 添加 XML 注释说明来源和含义

  代码模板:

  namespace Project.Grains;

  /// <summary>
  /// {功能中文名} ID 常量
  /// 对应客户端: ../Client/WuShuang2/Assets/LuaScript/common/{文件名}.lua
  /// </summary>
  public static class {功能名}Id
  {
      /// <summary>
      /// {常量中文名}
      /// 客户端: {客户端常量名} = {值}
      /// </summary>
      public const string {ConstantName} = "{value}";

      // 或者用 static readonly (如果是复杂类型)
      public static readonly string {ConstantName} = "{value}";
  }

  真实范例: ItemId.cs

  public static class ItemId
  {
      /// <summary>
      /// 金币
      /// 客户端: ItemId.Coin = "coin"
      /// </summary>
      public static readonly string Coin = "coin";

      /// <summary>
      /// 宝石
      /// 客户端: ItemId.Gem = "gem"
      /// </summary>
      public static readonly string Gem = "gem";

      /// <summary>
      /// 掉落装备 (特殊键,用于战斗掉落)
      /// </summary>
      public static readonly string DropEquip = "drop_equip";
  }

  验证清单:
  - 常量值与客户端完全一致
  - XML 注释说明客户端来源
  - 命名符合 C# 规范 (PascalCase)
  - 编译通过

  ---
  指令2: 配置预处理 (Config Preprocessing)

  触发条件: 需要查询静态配置数据

  目标: 预处理配置数据,将运行时查询转为启动时计算

  执行步骤:

  1. 查看客户端配置文件:
     - cat: "../Client/Configs/{表名}.cfg"
     - 确认: 字段含义, 数据格式

  2. 查看客户端使用方式:
     - glob: "../Client/WuShuang2/**/*{功能名}*.lua"
     - grep: "{配置字段名}" ../Client/WuShuang2/Assets/LuaScript/
     - 确认: 如何查询, 如何使用

  3. 检查生成的配置类:
     - 路径: src/Project.Grains/Config/Generated/GeneratedTable/{表名}Config.cs
     - 确认: 字段类型正确, 字段名一致

  4. 创建 Override 配置类:
     - 路径: src/Project.Grains/Config/Overrides/{表名}.cs
     - 实现: 预处理逻辑, 查询接口

  职责边界:

  | 职责       | 归属      | 示例                              |
  |----------|---------|---------------------------------|
  | ✅ 字段解析   | 配置类     | 解析 "victory|duration:60" → List |
  | ✅ 索引建立   | 配置类     | 按 (stageId, dropTag) 建立索引       |
  | ✅ 派生计算   | 配置类     | 计算总权重, 统计怪物数量                   |
  | ✅ 静态查询   | 配置类     | GetByName, GetDropGroups        |
  | ✅ 关联读取   | 配置类     | 在 OnAllConfigLoaded 中关联其他表      |
  | ❌ 业务逻辑   | 配置类     | 抽奖, 掉落生成, 战斗结算                  |
  | ✅ 纯静态业务  | 配置类静态方法 | 掉落抽奖 (drop_group.RollDrop)      |
  | ✅ 涉及状态修改 | 模块类     | 发放奖励, 扣除资源                      |

  代码结构:

  namespace Project.Config;

  /// <summary>
  /// {表名} 配置表
  /// {配置表的业务描述}
  /// 对应客户端配置: ../Client/Configs/{表名}.cfg
  /// </summary>
  public sealed partial class {表名} : BaseConfig
  {
      // ===== 静态索引 (全局共享) =====

      /// <summary>
      /// {索引说明}
      /// </summary>
      public static Dictionary<{KeyType}, {ValueType}> {IndexName} { get; } = new();

      // ===== 派生字段 (实例级别) =====

      /// <summary>
      /// {派生字段说明}
      /// 在 OnConfigLoaded/OnAllConfigLoaded 中计算
      /// </summary>
      public {Type} {FieldName} { get; private set; }

      // ===== 生命周期钩子 =====

      /// <summary>
      /// 单条配置加载完成时调用
      /// 用于: 字段解析, 自身派生计算, 建立索引
      /// </summary>
      public override void OnConfigLoaded()
      {
          base.OnConfigLoaded();

          // 1. 解析字段
          ParseFields();

          // 2. 计算派生字段
          DerivedField = Calculate();

          // 3. 建立索引
          if (!string.IsNullOrEmpty(key))
              IndexName[key] = this;
      }

      /// <summary>
      /// 所有配置加载完成后调用
      /// 用于: 关联其他表, 全局计算
      /// </summary>
      public override void OnAllConfigLoaded()
      {
          base.OnAllConfigLoaded();

          // 关联其他表
          var relatedConfig = Mgr?.Get<{OtherTable}>(relatedId);
          if (relatedConfig != null)
          {
              // 缓存关联数据
          }
      }

      // ===== 私有辅助方法 =====

      private void ParseFields()
      {
          // 解析逻辑
      }

      // ===== 静态查询接口 (仅必需的) =====

      /// <summary>
      /// {查询方法说明}
      /// </summary>
      public static {ReturnType}? {QueryMethod}({ParamType} param) =>
          IndexName.TryGetValue(param, out var result) ? result : null;

      // ===== 静态业务方法 (纯静态逻辑) =====

      /// <summary>
      /// {业务方法说明}
      /// 纯静态逻辑,不修改状态
      /// </summary>
      public static {ResultType} {BusinessMethod}(
          {ParamType1} param1,
          {ParamType2} param2,
          Random? random = null)
      {
          random ??= Random.Shared;

          // 1. 查询配置
          var config = QueryMethod(param1);

          // 2. 执行计算
          var result = Calculate(config, param2, random);

          return result;
      }
  }

  真实范例1: stage.cs (字段解析 + 查询接口)

  public sealed partial class stage : BaseConfig
  {
      // ===== 派生字段 =====

      /// <summary>
      /// 解析后的星级条件列表
      /// </summary>
      public List<StarCondition> Stars { get; private set; } = new();

      // ===== 生命周期钩子 =====

      public override void OnAllConfigLoaded()
      {
          base.OnAllConfigLoaded();
          ParseStars(); // 解析字段
      }

      // ===== 私有辅助方法 =====

      private void ParseStars()
      {
          if (string.IsNullOrEmpty(starConditions)) return;

          foreach (var part in starConditions.Split('|'))
          {
              var idx = part.IndexOf(':');
              if (idx > 0)
              {
                  var type = part[..idx].Trim();
                  var value = int.Parse(part[(idx + 1)..].Trim());
                  Stars.Add(new StarCondition { Type = type, Value = value });
              }
          }
      }

      // ===== 查询接口 =====

      /// <summary>
      /// 根据房间索引获取房间ID
      /// </summary>
      public string? GetRoomId(int roomIndex)
      {
          if (roomList == null || roomIndex < 1 || roomIndex > roomList.Count)
              return null;
          return roomList[roomIndex - 1];
      }

      // ===== 业务方法 =====

      /// <summary>
      /// 评判星级
      /// </summary>
      public int GetStars(bool win, int time, int revive, int hp = 0)
      {
          if (Stars.Count == 0) return win ? 1 : 0;
          if (Stars.All(c => Check(c, win, time, revive, hp))) return 3;
          if (Stars.Count >= 2 && Stars.Take(2).All(c => Check(c, win, time, revive, hp))) return 2;
          if (Check(Stars[0], win, time, revive, hp)) return 1;
          return 0;
      }
  }

  真实范例2: drop_group.cs (索引 + 纯静态业务逻辑)

  public sealed partial class drop_group : BaseConfig
  {
      // ===== 静态索引 =====

      public static Dictionary<(string stageId, string dropTag), List<drop_group>> DropIndex { get; } = new();

      // ===== 生命周期钩子 =====

      public override void OnAllConfigLoaded()
      {
          // 建立索引
          foreach (var stageId in stageList)
          {
              foreach (var dropTag in tagList)
              {
                  var key = (stageId, dropTag);
                  if (!DropIndex.TryGetValue(key, out var list))
                      DropIndex[key] = list = new List<drop_group>();
                  list.Add(this);
              }
          }
      }

      // ===== 静态查询接口 =====

      private static List<drop_group>? GetDropGroups(string stageId, string dropTag) =>
          DropIndex.TryGetValue((stageId, dropTag), out var entries) ? entries : null;

      // ===== 静态业务方法 (纯静态逻辑) =====

      /// <summary>
      /// 执行一次掉落抽取
      /// 纯静态逻辑,不修改玩家状态
      /// </summary>
      public static List<(string type, string name, int count)> RollDrop(
          string stageId,
          string dropTag,
          Random? random = null)
      {
          random ??= Random.Shared;
          var result = new List<(string type, string name, int count)>();

          var dropGroups = GetDropGroups(stageId, dropTag);
          if (dropGroups == null || dropGroups.Count == 0)
              return result;

          foreach (var dropGroup in dropGroups)
          {
              // 执行抽奖逻辑
              var reward = reward_pool.RandomReward(dropGroup.dropPool, random);
              if (reward != null)
              {
                  result.Add((reward.type, reward.name, reward.count));
              }
          }

          return result;
      }
  }

  真实范例3: room.cs (关联其他表)

  public sealed partial class room : BaseConfig
  {
      // ===== 派生字段 =====

      public int dropNumberBoss { get; set; }
      public int dropNumberElite { get; set; }
      public int dropNumberNormal { get; set; }

      // ===== 生命周期钩子 =====

      /// <summary>
      /// 使用 OnAllConfigLoaded 是因为依赖 trigger 表
      /// </summary>
      public override void OnAllConfigLoaded()
      {
          // 关联 trigger 表,获取怪物数量
          trigger? trigger = Mgr?.Get<trigger>(this.defaultTrigger);
          if (trigger == null) return;

          (dropNumberBoss, dropNumberElite, dropNumberNormal) = trigger.CountMonstersByDropTag();
      }
  }

  真实范例4: equipment.cs (建立名称索引)

  public sealed partial class equipment : BaseConfig
  {
      // ===== 静态索引 =====

      public static Dictionary<string, equipment> NameIndex { get; } = new();

      // ===== 生命周期钩子 =====

      public override void OnConfigLoaded()
      {
          if (string.IsNullOrEmpty(name)) return;
          NameIndex[name] = this;
      }

      // ===== 静态查询接口 =====

      public static equipment? GetByName(string equipmentName) =>
          NameIndex.TryGetValue(equipmentName, out var equip) ? equip : null;

      public static int GetIdByName(string equipmentName) =>
          GetByName(equipmentName)?.id ?? 0;
  }

  设计原则:

  1. 单一职责: 配置类只负责自己表的数据预处理和查询
  2. OnConfigLoaded vs OnAllConfigLoaded:
    - OnConfigLoaded: 仅依赖自身字段 (解析、计算、索引)
    - OnAllConfigLoaded: 需要关联其他表 (跨表读取、全局计算)
  3. 静态业务逻辑放哪里:
    - ✅ 纯静态计算 (无状态修改) → 配置类静态方法 (如 drop_group.RollDrop)
    - ❌ 涉及状态修改 → 模块类 (如发放奖励、扣除资源)
  4. 接口精简: 只提供业务必需的查询和业务方法,避免过度封装

  验证清单:
  - 客户端配置文件已查看
  - 客户端使用方式已理解
  - Override 类文件已创建
  - 生命周期钩子正确使用
  - 静态索引正确建立
  - 查询接口必需且精简
  - 静态业务逻辑职责清晰
  - XML 注释完整
  - 编译通过

  ---
  指令3: 模块强类型化 (Module Typing)

  触发条件: 需要读写模块数据 (_state.State.ModuleData.{模块名})

  目标: 将弱类型模块转为强类型,确保与客户端 100% 兼容

  执行步骤:

  1. 查看客户端模块定义:
     - 文件: module_def.lua
     - 确认: 模块字段, 字段类型, 默认值

  2. 查看客户端数据枚举:
     - 文件: data_enum.lua
     - 确认: JSON 序列化索引, 嵌套对象字段

  3. 查看客户端位操作 (如有):
     - 搜索: "MASK\|0x[0-9A-F]" 相关代码
     - 确认: 位字段布局, 掩码, 移位

  4. 设计强类型结构:
     - 模块类: src/Project.Grains/Player/Modules/{模块名}Module.cs
     - 数据类: src/Project.Grains/Player/Modules/{模块名}/{数据名}Data.cs

  5. 实现代码:
     - 序列化字段 (JsonPropertyName 数字索引)
     - 业务属性 (JsonIgnore, 直接读写位字段)
     - 业务方法 (增删改查, 自动维护派生字段)

  6. 编写验证测试:
     - 测试项目: test/{模块名}Test/
     - 验证: JSON 序列化, 位字段, 反序列化

  参考文档: 详见 CLAUDE.md 中的 "模块强类型化重构 SOP"

  真实范例1: BattleModule.cs (复杂业务逻辑)

  /// <summary>
  /// 战斗模块数据
  /// 对应客户端 module_def.lua 中的 BATTLE 模块
  /// </summary>
  public class BattleModule
  {
      // ===== 序列化字段 =====

      [JsonPropertyName("1")]
      public Dictionary<string, RoomDropData> Data { get; set; } = new();

      [JsonPropertyName("3")]
      public int Room { get; set; } = 0;

      [JsonPropertyName("4")]
      public string Stage { get; set; } = "";

      // ===== 业务方法 =====

      /// <summary>
      /// 判断玩家是否在战斗中
      /// </summary>
      public bool IsInBattle() => !string.IsNullOrEmpty(Stage);

      /// <summary>
      /// 开始战斗
      /// 集成: 验证关卡, 扣除资源, 初始化状态, 预生成掉落
      /// </summary>
      public bool StartBattle(string stageId, ModuleDef modules, ConfigMgr configMgr)
      {
          // 1. 验证关卡配置
          var stageConfig = configMgr.Get<stage>(stageId);
          if (stageConfig == null || stageConfig.isOpen != 1)
              return false;

          // 2. 检查并扣除资源
          if (!modules.ECO.ConsumeResources(stageConfig.cost))
              return false;

          // 3. 初始化战斗状态
          Stage = stageId;
          Room = 0;

          // 4. 预生成第1个房间的掉落数据
          var firstRoomId = stageConfig.GetRoomId(1);
          if (firstRoomId != null)
          {
              var dropData = RoomDropData.Create(stageId, firstRoomId, configMgr);
              if (dropData is { Count: > 0 })
              {
                  Data["1"] = dropData;
              }
          }

          return true;
      }

      /// <summary>
      /// 进入房间
      /// 验证房间索引, 预生成下一个房间掉落
      /// </summary>
      public bool EnterRoom(
          string stageId,
          int roomIndex,
          string roomId,
          int time,
          string? fateRoom,
          ConfigMgr configMgr)
      {
          // 验证状态
          if (!IsInBattle() || Stage != stageId)
              return false;

          // 验证房间索引 (必须是当前房间+1, 防止跳关)
          if (roomIndex != Room + 1)
              return false;

          // 更新状态
          Room = roomIndex;

          // 预生成下一个房间掉落
          var stageConfig = configMgr.Get<stage>(stageId);
          if (stageConfig != null)
          {
              var nextRoomId = stageConfig.GetRoomId(roomIndex + 1);
              if (nextRoomId != null)
              {
                  var nextRoomIndex = (roomIndex + 1).ToString();
                  var dropData = RoomDropData.Create(stageId, nextRoomId, configMgr);
                  if (dropData is { Count: > 0 })
                  {
                      Data[nextRoomIndex] = dropData;
                  }
              }
          }

          return true;
      }
  }

  真实范例2: EconomicModule.cs (资源管理)

  /// <summary>
  /// 经济模块
  /// 对应客户端 module_def.lua 中的 ECO 模块
  /// </summary>
  public class EconomicModule
  {
      // ===== 序列化字段 =====

      [JsonPropertyName("1")]
      public Dictionary<string, int> d { get; set; } = new()
      {
          [ItemId.Coin] = 0,
          [ItemId.Gem] = 5000,
      };

      // ===== 便捷属性 =====

      [JsonIgnore]
      public int Coin
      {
          get => GetResourceCount(ItemId.Coin);
          set => d[ItemId.Coin] = value;
      }

      // ===== 业务方法 =====

      /// <summary>
      /// 获取资源数量
      /// </summary>
      public int GetResourceCount(string itemId)
      {
          return d.GetValueOrDefault(itemId, 0);
      }

      /// <summary>
      /// 检查资源是否足够
      /// </summary>
      public bool HasEnoughResources(item_number? cost)
      {
          if (cost == null || string.IsNullOrEmpty(cost.item_id) || cost.number <= 0)
              return true;
          return GetResourceCount(cost.item_id) >= cost.number;
      }

      /// <summary>
      /// 添加资源
      /// </summary>
      public void AddResource(string itemId, int count)
      {
          if (string.IsNullOrEmpty(itemId) || count == 0)
              return;
          d[itemId] = d.GetValueOrDefault(itemId, 0) + count;
      }

      /// <summary>
      /// 扣除资源
      /// </summary>
      public bool ConsumeResources(item_number? cost)
      {
          if (cost == null || string.IsNullOrEmpty(cost.item_id) || cost.number <= 0)
              return true;

          if (!HasEnoughResources(cost))
              return false;

          AddResource(cost.item_id, -cost.number);
          return true;
      }
  }

  真实范例3: EquipModule.cs (集合管理)

  /// <summary>
  /// 装备模块
  /// 对应客户端 module_def.lua 中的 EQUIP 模块
  /// </summary>
  public class EquipModule
  {
      // ===== 序列化字段 =====

      [JsonPropertyName("1")]
      public int ac { get; set; } = 0; // additional capacity

      [JsonPropertyName("2")]
      public int ec { get; set; } = 0; // equipment count

      [JsonPropertyName("3")]
      public Dictionary<string, EquipmentData> el { get; set; } = new();

      [JsonPropertyName("4")]
      public int euid { get; set; } = 1; // equipment unique id

      // ===== 业务方法 =====

      /// <summary>
      /// 添加装备
      /// 自动维护 ec 和 euid
      /// </summary>
      public string AddEquipment(EquipmentData equipment)
      {
          var id = euid.ToString();
          el[id] = equipment;
          euid++;
          ec = el.Count; // 自动维护 count
          return id;
      }

      /// <summary>
      /// 删除装备
      /// 自动维护 ec
      /// </summary>
      public bool RemoveEquipment(string equipId)
      {
          var removed = el.Remove(equipId);
          if (removed)
          {
              ec = el.Count; // 自动维护 count
          }
          return removed;
      }

      /// <summary>
      /// 获取装备总容量
      /// </summary>
      public int GetCapacity()
      {
          const int DEFAULT_CAPACITY = 100;
          return DEFAULT_CAPACITY + ac;
      }

      /// <summary>
      /// 检查容量是否已满
      /// </summary>
      public bool IsFull()
      {
          return ec >= GetCapacity();
      }
  }

  真实范例4: EquipmentData.cs (位字段数据类)

  /// <summary>
  /// 单个装备数据
  /// 对应客户端 DataEnum 中的 "equipment" 定义
  /// </summary>
  public class EquipmentData
  {
      // ===== 位字段常量 =====

      private const int TEMPLATE_ID_MASK = 0x0FFF;
      private const int TEMPLATE_ID_SHIFT = 16;
      private const int STARS_MASK = 0xFF;
      private const int STARS_SHIFT = 8;
      private const int LEVEL_MASK = 0xFF;
      private const int NEW_MASK = unchecked((int)0x80000000);

      // ===== 序列化字段 =====

      [JsonPropertyName("1")]
      public int base_value { get; set; }

      [JsonPropertyName("2")]
      public int distribution { get; set; }

      [JsonPropertyName("3")]
      public List<int> attr_list { get; set; } = new();

      // ===== 便捷访问属性 (零冗余, 直接读写位字段) =====

      [JsonIgnore]
      public int TemplateId
      {
          get => (base_value >> TEMPLATE_ID_SHIFT) & TEMPLATE_ID_MASK;
          set => base_value = (base_value & ~(TEMPLATE_ID_MASK << TEMPLATE_ID_SHIFT))
                            | ((value & TEMPLATE_ID_MASK) << TEMPLATE_ID_SHIFT);
      }

      [JsonIgnore]
      public int Stars
      {
          get => (base_value >> STARS_SHIFT) & STARS_MASK;
          set => base_value = (base_value & ~(STARS_MASK << STARS_SHIFT))
                            | ((value & STARS_MASK) << STARS_SHIFT);
      }

      [JsonIgnore]
      public int Level
      {
          get => base_value & LEVEL_MASK;
          set => base_value = (base_value & ~LEVEL_MASK) | (value & LEVEL_MASK);
      }

      [JsonIgnore]
      public bool IsNew
      {
          get => (base_value & NEW_MASK) != 0;
          set
          {
              if (value)
                  base_value |= NEW_MASK;
              else
                  base_value &= ~NEW_MASK;
          }
      }

      // ===== 工厂方法 =====

      public static EquipmentData Create(
          int templateId,
          int stars = 1,
          int level = 1,
          int distribution = 0,
          bool isNew = true)
      {
          return new EquipmentData
          {
              distribution = distribution,
              TemplateId = templateId,
              Stars = stars,
              Level = level,
              IsNew = isNew
          };
      }
  }

  设计原则:

  1. 零冗余设计: 属性直接读写序列化字段的位,不设中间变量
  2. 自动维护派生字段: 在业务方法中自动维护 count、id 等派生字段
  3. 业务封装: 隐藏复杂逻辑 (如位操作、验证),暴露业务语义
  4. 集成业务方法: 模块方法可以集成多个步骤 (如 StartBattle 包含验证、扣费、初始化、预生成)

  验证清单:
  - JSON 格式与客户端完全一致
  - 位字段布局与客户端完全一致
  - 序列化往返测试通过
  - 业务方法自动维护派生字段
  - 编译通过

  ---
  指令4: 实现消息函数 (Message Implementation)

  目标: 编写消息处理器,作为连接 request 和 response 的胶水代码

  执行步骤:

  1. 依赖检查:
     - 确认: 指令1 (常量), 指令2 (配置), 指令3 (模块) 都已完成
     - 如有缺失: 回到对应指令完成依赖

  2. 编写消息处理器:
     - 文件: src/Project.Grains/Player/MessageHandler/PlayerGrain.{模块名}.cs
     - 方法: [PlayerMessageHandler(tag)] async Task<response> Handle{消息名}Async(request, response)

  3. 遵循胶水代码原则:
     - 提取参数
     - 验证参数
     - 调用业务逻辑 (模块方法 / 配置查询)
     - 填充响应
     - 记录日志

  胶水代码原则:

  | 原则                | 说明             | 示例                                                  |
  |-------------------|----------------|-----------------------------------------------------|
  | ✅ 参数提取            | 从 request 提取参数 | var stageId = request.stage_id;                     |
  | ✅ 参数验证            | 边界检查、权限检查      | if (string.IsNullOrEmpty(stageId)) return response; |
  | ✅ 调用业务逻辑          | 调用模块方法 / 配置查询  | var success = modules.BATTLE.StartBattle(...);      |
  | ✅ 填充响应            | 设置 response 字段 | response.ret_code = success ? 1 : 0;                |
  | ✅ 记录日志            | 记录关键操作         | _logger.LogInformation("开始战斗: {StageId}", stageId); |
  | ❌ 不写业务逻辑          | 不在消息函数中写复杂逻辑   | 在消息函数中写战斗结算                                         |
  | ❌ 不直接访问配置字段       | 使用配置类提供的接口     | ~~`config.starConditions.Split('                    |
  | ❌ 不手动设置 sync_list | 框架自动处理         | response.sync_list = ...                            |

  代码结构:

  [PlayerMessageHandler(C2S_Protocol.{MESSAGE_TAG}.Tag)]
  private async Task<C2S_SprotoType.{MESSAGE}.response> Handle{MESSAGE}Async(
      C2S_SprotoType.{MESSAGE}.request request,
      C2S_SprotoType.{MESSAGE}.response response)
  {
      // 1. 提取参数
      var param1 = request.param1;
      var param2 = request.param2;

      // 2. 参数验证
      if (param1 <= 0)
      {
          _logger.LogWarning("玩家 {PlayerId} 参数无效: param1={Param1}",
              _state.State.PlayerToken, param1);
          response.ret_code = 0;
          return response;
      }

      // 3. 调用业务逻辑
      var modules = _state.State.ModuleData;
      var success = modules.{MODULE}.DoSomething(param1, param2);

      // 4. 查询配置 (如需要)
      var config = _configMgr.Get<{ConfigTable}>(configId);
      if (config == null)
      {
          _logger.LogWarning("配置不存在: {ConfigId}", configId);
          response.ret_code = 0;
          return response;
      }

      // 5. 修改状态 (框架自动同步到 sync_list)
      modules.ECO.AddResource(ItemId.Coin, 100);

      // 6. 填充响应
      response.ret_code = success ? 1 : 0;

      // 7. 保存状态
      await _state.WriteStateAsync();

      // 8. 记录日志
      _logger.LogInformation("玩家 {PlayerId} {操作}成功: param1={Param1}",
          _state.State.PlayerToken, param1);

      return response;
  }

  真实范例1: PlayerGrain.Battle.cs - BATTLE_START (简单调用)

  [PlayerMessageHandler(C2S_Protocol.BATTLE_START.Tag)]
  private async Task<C2S_SprotoType.BATTLE_START.response> HandleBATTLE_STARTAsync(
      C2S_SprotoType.BATTLE_START.request request,
      C2S_SprotoType.BATTLE_START.response response)
  {
      var stageId = request.stage_id;

      var modules = _state.State.ModuleData;

      // 调用战斗模块的业务逻辑 (所有逻辑都在模块中)
      var success = modules.BATTLE.StartBattle(stageId, modules, _configMgr);

      if (success)
      {
          await _state.WriteStateAsync();
          response.ret_code = 1;
          _logger.LogInformation("玩家 {PlayerId} 开始战斗成功: {StageId}",
              _state.State.PlayerToken, stageId);
      }
      else
      {
          response.ret_code = 0;
          _logger.LogWarning("玩家 {PlayerId} 开始战斗失败: {StageId}",
              _state.State.PlayerToken, stageId);
      }

      return response;
  }

  真实范例2: PlayerGrain.Battle.cs - BATTLE_ENTER_ROOM (参数验证 + 配置查询)

  [PlayerMessageHandler(C2S_Protocol.BATTLE_ENTER_ROOM.Tag)]
  private async Task<C2S_SprotoType.BATTLE_ENTER_ROOM.response> HandleBATTLE_ENTER_ROOMAsync(
      C2S_SprotoType.BATTLE_ENTER_ROOM.request request,
      C2S_SprotoType.BATTLE_ENTER_ROOM.response response)
  {
      // 1. 提取参数
      var stageId = request.stage_id;
      var roomIndex = (int)request.room_index;
      var time = (int)request.time;
      var fateRoom = request.fate_room;

      var modules = _state.State.ModuleData;

      // 2. 查询配置
      var stageConfig = _configMgr.Get<stage>(stageId);
      if (stageConfig == null)
      {
          response.ret_code = 0;
          _logger.LogWarning("玩家 {PlayerId} 进入房间失败: 关卡配置不存在 {StageId}",
              _state.State.PlayerToken, stageId);
          return response;
      }

      // 3. 获取房间ID (使用配置类提供的接口)
      var roomId = stageConfig.GetRoomId(roomIndex);
      if (roomId == null)
      {
          response.ret_code = 0;
          _logger.LogWarning("玩家 {PlayerId} 进入房间失败: 房间索引越界",
              _state.State.PlayerToken);
          return response;
      }

      // 4. 调用业务逻辑
      var success = modules.BATTLE.EnterRoom(stageId, roomIndex, roomId, time, fateRoom, _configMgr);

      if (success)
      {
          await _state.WriteStateAsync();
          response.ret_code = 1;
          _logger.LogInformation("玩家 {PlayerId} 进入房间成功: 关卡={StageId}, 房间={RoomIndex}",
              _state.State.PlayerToken, stageId, roomIndex);
      }
      else
      {
          response.ret_code = 0;
          _logger.LogWarning("玩家 {PlayerId} 进入房间失败",
              _state.State.PlayerToken);
      }

      return response;
  }

  设计原则:

  1. 薄层设计: 函数体尽可能短 (建议 < 30 行)
  2. 职责单一: 只做数据转换和调用,不写业务逻辑
  3. 日志完整: 记录关键操作、参数、结果、失败原因
  4. 错误处理: 参数验证、配置检查、业务失败都要有对应处理

  验证清单:
  - 所有依赖已实现 (常量、配置、模块)
  - 函数体简洁 (胶水代码)
  - 参数验证完整
  - 日志记录完整
  - 编译通过

  ---
  指令5: 编译验证 (Compile Verification)

  目标: 确保代码编译通过,0 错误 0 警告

  执行步骤:

  # 编译整个解决方案
  cd Server
  dotnet build Project.Server.sln

  # 或编译单个项目
  dotnet build src/Project.Grains/Project.Grains.csproj

  常见错误处理:

  | 错误类型                | 原因                    | 解决方案            |
  |---------------------|-----------------------|-----------------|
  | 类型不匹配               | 模块强类型化后,旧代码仍使用 object | 修改为强类型访问        |
  | JsonPropertyName 冲突 | 业务属性忘记标记 JsonIgnore   | 添加 [JsonIgnore] |
  | 位操作错误               | 掩码或移位错误               | 对照客户端代码检查       |
  | 缺少引用                | 缺少 using 或项目引用        | 添加引用            |

  验证清单:
  - 编译通过 (0 个错误)
  - 无警告 (0 个警告)
  - 所有文件保存

  ---
  指令6: 客户端测试 (Client Testing)

  目标: 启动客户端和服务端,验证消息往返

  执行步骤:

  1. 启动服务端:
     - 启动 Silo: cd src/Project.Silo && dotnet run
     - 启动 Gateway: cd src/Project.Gateway && dotnet run

  2. 启动客户端:
     - 打开 Unity 项目: ../Client/WuShuang2
     - 运行游戏

  3. 触发消息:
     - 在游戏中执行对应操作
     - 观察客户端日志
     - 观察服务端日志

  4. 验证结果:
     - 检查 response.ret_code
     - 检查 sync_list 是否同步
     - 检查客户端 UI 是否正确刷新

  验证清单:
  - 服务端接收到消息
  - 服务端返回正确响应
  - 客户端接收到响应
  - sync_list 正确同步
  - 客户端 UI 正确刷新
  - 无异常日志

  ---
  📊 完整工作流示例

  场景: 实现 "购买商店物品" 消息

  指令0: 前置检查

  # 1. 查看协议定义
  cat ../Client/WuShuang2/Assets/LuaScript/common/proto_def.lua | grep -A 5 "BUY_SHOP_ITEM"

  # 2. 查看客户端发送时机
  grep -n "session:call.*buy_shop_item" ../Client/WuShuang2/**/*.lua

  # 3. 查看客户端数据消费逻辑
  grep -n "economic_module.gold" ../Client/WuShuang2/**/*.lua

  # 4. 查看客户端接收处理
  grep -n "function.*on_buy_shop_item" ../Client/WuShuang2/**/*.lua

  输出: 理解购买流程、扣除金币、发放物品

  指令1: 常量对齐

  检查是否需要商店相关常量 → 已有 ItemId.cs,无需新增

  指令2: 配置预处理

  创建 shop_item.cs:

  public sealed partial class shop_item : BaseConfig
  {
      /// <summary>
      /// 解析后的消耗
      /// </summary>
      public item_number ParsedCost { get; private set; }

      /// <summary>
      /// 解析后的奖励
      /// </summary>
      public item_number ParsedReward { get; private set; }

      public override void OnConfigLoaded()
      {
          base.OnConfigLoaded();

          // 解析消耗字段 "gold:100" → {item_id="gold", number=100}
          ParsedCost = ParseItemNumber(cost);

          // 解析奖励字段
          ParsedReward = ParseItemNumber(reward);
      }

      private item_number ParseItemNumber(string str)
      {
          var parts = str.Split(':');
          return new item_number
          {
              item_id = parts[0],
              number = int.Parse(parts[1])
          };
      }
  }

  指令3: 模块强类型化

  检查 EconomicModule → 已实现,无需新增

  指令4: 实现消息函数

  创建 PlayerGrain.Shop.cs:

  [PlayerMessageHandler(C2S_Protocol.BUY_SHOP_ITEM.Tag)]
  private async Task<C2S_SprotoType.BUY_SHOP_ITEM.response> HandleBUY_SHOP_ITEMAsync(
      C2S_SprotoType.BUY_SHOP_ITEM.request request,
      C2S_SprotoType.BUY_SHOP_ITEM.response response)
  {
      // 1. 提取参数
      var itemId = request.item_id;

      // 2. 查询配置
      var shopItem = _configMgr.Get<shop_item>(itemId);
      if (shopItem == null)
      {
          _logger.LogWarning("商品不存在: {ItemId}", itemId);
          response.ret_code = 0;
          return response;
      }

      var modules = _state.State.ModuleData;

      // 3. 检查资源
      if (!modules.ECO.HasEnoughResources(shopItem.ParsedCost))
      {
          _logger.LogWarning("玩家 {PlayerId} 金币不足",
              _state.State.PlayerToken);
          response.ret_code = 0;
          return response;
      }

      // 4. 扣除资源
      modules.ECO.ConsumeResources(shopItem.ParsedCost);

      // 5. 发放奖励
      modules.ECO.AddResource(shopItem.ParsedReward);

      // 6. 保存状态
      await _state.WriteStateAsync();

      response.ret_code = 1;
      _logger.LogInformation("玩家 {PlayerId} 购买商品成功: {ItemId}",
          _state.State.PlayerToken, itemId);

      return response;
  }

  指令5: 编译验证

  dotnet build src/Project.Grains/Project.Grains.csproj

  ✅ 编译通过

  指令6: 客户端测试

  1. 启动服务端
  2. 启动客户端
  3. 打开商店,点击购买
  4. 观察金币扣除,物品增加

  ✅ 测试通过

  ---
  📋 快速检查清单

  使用此清单确保每个消息都正确实现:

  ## 消息: {消息名}

  ### 指令0: 前置检查
  - [ ] 协议定义已确认
  - [ ] 客户端发送时机已确认
  - [ ] 客户端数据消费逻辑已确认

  ### 依赖检查
  - [ ] 需要常量: {是/否} → {常量类名}
  - [ ] 需要配置: {是/否} → {配置表名}
  - [ ] 需要模块: {是/否} → {模块名}

  ### 指令1: 常量对齐
  - [ ] 常量类已创建 (如需要)
  - [ ] 常量值与客户端一致
  - [ ] 编译通过

  ### 指令2: 配置预处理
  - [ ] Override 类已创建 (如需要)
  - [ ] 生命周期钩子正确实现
  - [ ] 静态索引/查询接口已实现
  - [ ] 编译通过

  ### 指令3: 模块强类型化
  - [ ] 模块类已创建 (如需要)
  - [ ] JSON 格式与客户端一致
  - [ ] 业务方法已实现
  - [ ] 测试通过
  - [ ] 编译通过

  ### 指令4: 实现消息函数
  - [ ] 消息处理器已创建
  - [ ] 参数验证完整
  - [ ] 业务逻辑调用正确
  - [ ] 日志记录完整
  - [ ] 编译通过

  ### 指令5: 编译验证
  - [ ] 0 个错误
  - [ ] 0 个警告

  ### 指令6: 客户端测试
  - [ ] 消息往返正常
  - [ ] sync_list 同步正确
  - [ ] UI 刷新正确

  ---
  🎓 核心概念总结

  三层分离

  | 层次  | 职责      | 位置                     | 示例                                 |
  |-----|---------|------------------------|------------------------------------|
  | 静态层 | 配置数据预处理 | Config/Overrides/      | stage.cs, drop_group.cs            |
  | 业务层 | 模块业务逻辑  | Player/Modules/        | BattleModule.cs, EconomicModule.cs |
  | 胶水层 | 消息处理器   | Player/MessageHandler/ | PlayerGrain.Battle.cs              |

  职责边界

  配置类 (静态层):
  - ✅ 字段解析、索引建立、派生计算
  - ✅ 静态查询接口
  - ✅ 纯静态业务逻辑 (如 drop_group.RollDrop)
  - ❌ 状态修改

  模块类 (业务层):
  - ✅ 封装状态修改
  - ✅ 业务逻辑集成
  - ✅ 自动维护派生字段
  - ❌ 配置数据解析

  消息处理器 (胶水层):
  - ✅ 参数提取和验证
  - ✅ 调用配置查询和模块方法
  - ✅ 填充响应和记录日志
  - ❌ 业务逻辑实现

  设计原则

  1. 自底向上: 先依赖后业务
  2. 单一职责: 每个类只负责一件事
  3. 零冗余: 属性直接读写位字段
  4. 客户端对齐: 常量、配置、模块数据与客户端 100% 一致
  5. 胶水代码: 消息处理器尽可能薄 帮我修改到项目的CLAUDE.md中
```

**Claude**: 我需要将这个标准化工作流程添加到项目的 CLAUDE.md 文件中。让我先查看当前的 CLAUDE.md 文件结构。

[Claude 读取了 CLAUDE.md 文件]

好的,我现在将把您提供的"服务器消息开发标准化工作流程"添加到项目的 CLAUDE.md 文件的末尾。

[Claude 使用 Edit 工具将完整的工作流程添加到 CLAUDE.md 文件末尾,包含:
- 核心理念
- 总体流程图
- 指令0-6的详细步骤
- 完整工作流示例
- 快速检查清单
- 核心概念总结]

完成!我已经成功将"服务器消息开发标准化工作流程"添加到项目的 CLAUDE.md 文件中。

这个完整的工作流程包含了:

✅ **核心理念** - 三层分离原则和自底向上原则
✅ **总体流程图** - 6个指令的完整流程
✅ **指令0-6** - 详细的执行步骤、代码模板和真实范例
✅ **完整工作流示例** - "购买商店物品"的实战示例
✅ **快速检查清单** - 确保每个消息正确实现
✅ **核心概念总结** - 三层分离、职责边界、设计原则

文件已更新,所有内容都已正确添加到 CLAUDE.md 的末尾,形成了一个完整的标准化开发指南。

---

### 对话2
**用户**: 保存对话

**Claude**: 好的,我来帮你保存对话。根据全局 CLAUDE.md 中的备份对话规范,我需要:

1. 保存完整对话到 `sessions/` 目录
2. 生成分析报告到 `analysis/` 目录

让我开始执行备份操作。

[后续操作正在进行中...]
